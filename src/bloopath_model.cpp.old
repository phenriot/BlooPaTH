//#include <Rcpp.h>
#include <RcppArmadillo.h>
#include <RcppArmadilloExtensions/sample.h>

//[[Rcpp::depends("RcppArmadillo")]]

using namespace Rcpp;
using namespace RcppArmadillo;
using namespace std;


//out_prob = probability of leaving the hospital after being in each of the wards
// WT =  ward transition

Environment pkg_truncnorm = Environment::namespace_env("truncnorm");
Environment pkg_mc2d = Environment::namespace_env("mc2d");
Environment pkg_stats = Environment::namespace_env("stats");

Function random_truncnorm=pkg_truncnorm["rtruncnorm"];
Function random_pert = pkg_mc2d["rpert"];
Function random_lnorm= pkg_stats["rlnorm"];
Function random_norm= pkg_stats["rnorm"];

// [[Rcpp::export]]
List transform_list(int nb_proc, arma::imat table_proc_equip) {

  List list_proc(nb_proc);

  for(int i = 0;i<list_proc.length();i++) {

    list_proc(i) =  arma::irowvec(1);

  }


  for(int i = 0;i<size(table_proc_equip)(0);i++) {

    arma::irowvec current_p ;
    current_p = table_proc_equip(i,0);
    arma::irowvec current_e ;
    current_e =table_proc_equip(i,1);


    for(int j=0; j<list_proc.length();j++ ) {

      arma::irowvec storage_vec = list_proc(j);

      if(j==current_p(0)-1) {list_proc(j) = join_rows(storage_vec,current_e);}

    }


    // arma::irowvec current_p = table_test(i,1);
    // arma::irowvec current_e = table_test(i,2);
    //
    // if(i==current_p(0)) {list_test(i) = join_rows(storage_vec,current_e);}


  }

  for(int i = 0;i<list_proc.length();i++) {

    arma::irowvec subset = list_proc(i);

    subset.shed_col(0);
    list_proc(i)=subset;

  }

  return list_proc;
}

// [[Rcpp::export]]
List BlooPaTH_model(int t, //simulation time
                        int n_patients, // number of patients
                        int nb_wards, // number of wards
                        int nb_adm, // number of admission routes
                        arma::drowvec prev_init, // initial prevalence for each admission route
                        std::string prev_type, //"ward" level or "hospital" level
                        arma::dmat WT_matrix, //transition matrix, specific format (merged matrix for all admission routes) but any time-step will do
                        arma::dmat init_prob, // matrix of probabilities of admission for first ward for both adm routes, nb_adm rows .
                        arma::dcolvec adm_prob,// probabilities of admission for each route
                        int nb_procedures, //number of procedures
                        int nb_equipments, // number of equipments
                        arma::dmat PPM_matrix, // probabilities of undergoing procedures (columns) in each ward (row), merged for both admission routes; Any time-step is ok but need to be the same as the transition matrix
                        Rcpp::DataFrame dist_risk, // distribution parameters of the risk for each procedure (dist can be normal, log-normal or pert)
                        arma::imat nb_material_new, // quantity of equipment for each type in  each ward
                        arma::imat nb_material_used, // quantity of equipment for each type in  each ward
                        arma::imat nb_material_contaminated, // quantity of equipment for each type in  each ward
                        int min_e_phase, // min value for the eclipse phase
                        int max_e_phase, // max value for the eclipse phase
                        float time_step, // must be expressed in hours (ex: if time step is 5min then inform 1/12)
                        bool patient_followup, // useless
                        arma::imat table_proc_equip, // correspondence table between procedures (col 1) and equipments (col 2)
                        StringVector procedure_names, // vector of procedure names
                        StringVector equipment_names, // vector of equipments names
                        arma::drowvec sterilization_prob, // probability of good sterilization for each equipment
                        std::string eq_quantity, // should the quantity be fixed ? "fixed" (then refill quantities not used) or "variable"
                        arma::imat refill_quantities, // quantity of equipment to add to the pool of unused equipment for each type at each refill event
                        arma::fmat refill_freq,// refill frequency for each equipment type (must be expressed in hours)
                        arma::fmat equip_bin,// frequence alaquelle on jete le materiel
                        std::string output="simple",//if output == "all" then returns all tables, if "simple" returns nb of new cases each day and new entry in the hospital
                        float prob_screening=0, // probability of systematic screening upon admission
                        std::string intervention = "none",//none, patient-based or ward-based
                        arma::irowvec at_risk_wards=0, // vector giving the most at risk wards
                        arma::frowvec threshold_reuse=0)// threshold before equipment reuse 
  {

  List list_proc_equip = transform_list(nb_procedures,table_proc_equip);
  

  //clean freq en vecteur pour associer a chaque type de materiel
  arma::dmat storage_adm_TM;
  arma::dmat storage_adm_PPM;
  arma::drowvec storage_init_prob;

  StringVector subset_col_proc = table_proc_equip[0];
  StringVector subset_col_equip = table_proc_equip[0];

 //vector of indices to recover each individual transition matrix as the entered matrix is of size ((nb_wards+1)*nb_adm) x (nb_wards+1)
  arma::irowvec index_TM = arma::linspace<arma::irowvec>(0,(nb_wards+1)*nb_adm,nb_adm+1);

  
  arma::irowvec index_PPM = arma::linspace<arma::irowvec>(0,(nb_wards)*nb_adm,nb_adm+1);

  //WT_matrix List = different transition matrices associated with different admission places
  // WT_matrix must be same dim than adm_prob
  //adm_prob different from init_prob,adm_prob = admission place and init_prob = first place where proc is performed
  //proc_names, PPM_matrix, and dist risk must be in same order
  //dist_risk = DF with 4 cols, first 3 cols = distribution parameters, fourth col = dist type = "norm", "lnorm" or "pert"
  //PPM_matrix = matrix with nb_proc rows and nb_wards columns : prob of undergoing different kinds of procedures depending on wards
  //gamma = E -> I
  //rho_vec = vector of probs of contaminating material, depending on proc type
  //clean_freq =  frequency at which material is sterilized/thrown away
  //clean_eff = efficiency of material cleaning
  //proc_duration and time step must be in hours

  if(prev_type=="ward" && prev_init.size() != nb_wards) {stop("Error: Initial prevalence type chosen is at a ward-level, should be the same size as the number of wards");}
  if(prev_type=="hospital" && prev_init.size() != nb_adm) {stop("Error: Initial prevalence type chosen is at a hospital-level, should be the same size as the number of admission routes");}
  //if(WT_matrix.n_rows < n_wards) {stop("Error: number of rows in WT_matrix < n_wards");}



  //vector for 2= positive, 0=negative
  arma::drowvec pos_neg_vec = {0,2};
  arma::dcolvec cont_neg_vec = {0,1};
  arma::dcolvec failure_success = {0,1};
  arma::drowvec screened_pos_neg_vec = {1,2};


  //number of patients in the hospital
  int number_pat = n_patients;

  //Matrix for status of patients in the hospital
  arma::dmat pop_hosp_status = arma::dmat(n_patients,t+1,arma::fill::zeros); //No need to t+1 because first index = 0

  //Matrix for available material through time
  //arma::dmat available_mat_time = arma::dmat(nb_equipments,t+1,arma::fill::zeros); //No need to t+1 because first index = 0

    
    arma::icube available_mat_time(nb_equipments,nb_wards,t+1);
    
    arma::icube cont_mat_time(nb_equipments,nb_wards,t+1);
    
    arma::icube used_mat_time(nb_equipments,nb_wards,t+1); 
   
 

  // //Matrix for contaminated material through time
  // arma::dmat contaminated_mat_time = arma::dmat(nb_equipments,t+1,arma::fill::zeros); //No need to t+1 because first index = 0
  //
  // //Matrix for used material through time
  // arma::dmat used_mat_time = arma::dmat(nb_equipments,t+1,arma::fill::zeros); //No need to t+1 because first index = 0

  //Matrix for status of patients in the hospital
  //arma::dmat pop_hosp_status = arma::dmat(n_patients,t,arma::fill::zeros); //No need to t+1 because first index = 0

  //int nb_pos = round(n_patients*prev_init);

  //2 means HCV + and 0 HCV -, in pop_hosp_status 1 will mean contaminated but not infectious
  // arma::drowvec pos_patients(nb_pos,arma::fill::ones) ;
  // pos_patients = pos_patients+1;

  //arma::drowvec neg_patients(n_patients-nb_pos,arma::fill::zeros) ;

  // arma::drowvec vec_join = join_rows(pos_patients,neg_patients );
  //
  // arma::drowvec vec_init = sample(vec_join,n_patients,false);
  //
  // //For time t=0 initial status are added to pop_hosp
  // for(int i = 0; i<n_patients;i++) {
  //
  //   pop_hosp_status(i,0) = vec_init[i] ;
  //
  // }


  // counting nb of patients hospitalized on the periode 
  int count_patients = 0;
  
  // counting nb of tests
  int count_tests = 0;

  // counting nb of patients hospitalized on the periode in each ward
  arma::irowvec count_patient_ward(nb_wards,arma::fill::zeros);

  // counting nb of contaminated patients hospitalized on the periode in each ward
  arma::irowvec cont_new_patient_ward(nb_wards,arma::fill::zeros);

  //Matrix for location of patients in the hospital
  arma::dmat pop_hosp_loc = arma::dmat(n_patients,t+1,arma::fill::zeros); //No need to t+1 because first index = 0

  //Matrix of procedures undergone by patients during hosp
  arma::dmat pop_proc = arma::dmat(n_patients,t+1,arma::fill::zeros); //No need to t+1 because first index = 0

  //Matrix of number of previously used materials (initialized at 0 for each procedure in each ward)
  arma::imat Npu_mat = nb_material_used;

  //Matrix of number of available material (initialized at nb_material because no material has been used at start)
  arma::imat N_mat = nb_material_new;

  //Matrix of number of contaminated materials for each ward and each procedure (C compartment)
  arma::imat C_mat = nb_material_contaminated;

  //Matrix storing all departures of patients
  arma::umat patient_departure; //= arma::dmat(2,1,arma::fill::zeros);

  //sequence for wards
  arma::drowvec wards_seq = arma::linspace<arma::drowvec>(1,nb_wards,nb_wards);

  //sequence for admission places
  arma::drowvec adm_seq = arma::linspace<arma::drowvec>(1,nb_adm,nb_adm);

  //sequence for proc
  arma::drowvec proc_seq = arma::linspace<arma::drowvec>(1,nb_procedures,nb_procedures);

  //incidence vector
  arma::drowvec incidence(t,arma::fill::zeros);

  //number of s patients vector
  arma::drowvec s_patients(t,arma::fill::zeros);

  //new patients
  arma::drowvec new_patient_vec(t,arma::fill::zeros);
  new_patient_vec(0) = n_patients;

  //contamianetd new patients
  arma::drowvec cont_new_patient_vec(t,arma::fill::zeros);

  //time counter to assign patient in the E state to the I state
  arma::drowvec state_counter(n_patients,arma::fill::zeros);// starts at 0

  //time counter to assign patient in the E state to the I state
  arma::imat refill_counter(nb_equipments,nb_wards,arma::fill::zeros);// starts at 0

  //time counter to assign patient in the E state to the I state
  arma::imat bin_counter(nb_equipments,nb_wards,arma::fill::zeros);// starts at 0

  
  //store equipment usage
  arma::imat eq_usage(nb_equipments,nb_wards,arma::fill::zeros);// starts at 0
  
  //time counter to assign patient in the E state to the I state
  arma::drowvec admission_route(n_patients,arma::fill::zeros);// starts at 0
  
  //screened vector upon admission
  arma::drowvec screened(n_patients,arma::fill::zeros);// starts at 0

  arma::dcolvec screen_prob_vec = {1-prob_screening,prob_screening};
  
    //Matrix to know in patient has been screened for HCV or HBV or HIV , 0 = not screened, 1 = screened and - , 2 = screened and +
  arma::imat ward_screening = arma::imat(n_patients,nb_wards,arma::fill::zeros); //No need to t+1 because first index = 0

  //vector to store nb of infection events
  arma::drowvec ward_event(nb_wards,arma::fill::zeros);// starts at 0

 //matrix to store nb of suceptible patients in each ward
  arma::dmat ward_s = arma::dmat(nb_wards,t+1,arma::fill::zeros);
  
  //vector to store nb of infection events
  arma::drowvec cont_mat(nb_equipments,arma::fill::zeros);// starts at 0
  
  //vector to store nb of infection events
  arma::drowvec used_mat(nb_equipments,arma::fill::zeros);// starts at 0
  
  //vector to store nb of proc by proc
  arma::drowvec vec_nb_proc(nb_procedures,arma::fill::zeros);// starts at 0

  //vector to store nb of infection per equipment type
  arma::drowvec inf_eq(nb_equipments,arma::fill::zeros);// starts at 0
  
  //Matrix to know if a patient has already been into a given ward
  arma::imat mat_patient_ward = arma::imat(n_patients,nb_wards,arma::fill::zeros); //No need to t+1 because first index = 0
  
  arma::irowvec init_patient_wards(nb_wards,arma::fill::zeros);
  
  arma::irowvec fill_screened_s = std::vector<int>(nb_wards,1);
  
  arma::irowvec fill_screened_i = std::vector<int>(nb_wards,2);
  
  arma::irowvec test_eq(t,arma::fill::zeros);
  
  arma::irowvec test_eq_cont(t,arma::fill::zeros);
  
  arma::irowvec test_eq_u(t,arma::fill::zeros);
  
  //
  arma::drowvec e_phase = Rcpp::runif( n_patients, min_e_phase, max_e_phase);
  e_phase = round(e_phase);

  //Rcout << e_phase;
  arma::drowvec patient_fstatus(t,arma::fill::zeros) ;
  arma::drowvec patient_floc(t,arma::fill::zeros) ;
  arma::drowvec patient_fproc(t,arma::fill::zeros) ;

  arma::drowvec patient_id =  arma::linspace<arma::drowvec>(0,n_patients-1,n_patients);
  arma::drowvec rdm_patient  = sample(patient_id,n_patients,false);

  // For time t=0 initial status are added to pop_hosp

  for(int i = 0; i<n_patients;i++) {

    
    
    admission_route(i) = sample(adm_seq,1,false,adm_prob)(0);
    //Rcout<<admission_ward(i);
    storage_init_prob= init_prob.row(admission_route(i)-1);
    //Rcout<<wards_seq;
    pop_hosp_loc(i,0) = sample(wards_seq,1,false,storage_init_prob.t())(0);
    //Rcout << "ici";

    if(prev_type == "hospital") {
      
    arma::dcolvec pos_neg_prob = {1-prev_init((admission_route(i)-1)),prev_init((admission_route(i)-1))};

    //test if patient is infected depending on adm route
    pop_hosp_status(i,0) = sample(pos_neg_vec,1,false,pos_neg_prob)(0);

    if(pop_hosp_status(i,0)==2) {cont_new_patient_vec(0) = cont_new_patient_vec(0)+1;}
    
    }
    
    if(prev_type == "ward") {
      
      arma::dcolvec pos_neg_prob = {1-prev_init((pop_hosp_loc(i,0)-1)),prev_init((pop_hosp_loc(i,0)-1))};
      
      Rcout<< pos_neg_prob;
      //test if patient is infected depending on adm route
      pop_hosp_status(i,0) = sample(pos_neg_vec,1,false,pos_neg_prob)(0);
      
      if(pop_hosp_status(i,0)==2) {cont_new_patient_vec(0) = cont_new_patient_vec(0)+1;}
      
    }

    
      
    // if(intervention == "ward-based" && std::find(at_risk_wards.begin(), at_risk_wards.end(), (pop_hosp_loc(i,0))) != at_risk_wards.end()) {
    //   
    //   int screen = sample(failure_success,1,false,screen_prob_vec)(0);
    //   
    //   if (screen==1 && pop_hosp_status(i,0)==0) {ward_screening(i,(pop_hosp_loc(i,0)-1))=1;  count_tests = count_tests +1 ;}
    //   if (screen==1 && pop_hosp_status(i,0)==2) {ward_screening(i,(pop_hosp_loc(i,0)-1))=2;  count_tests = count_tests +1 ;}
    //   
    // }
    
    if((intervention == "ward-based" or intervention == "ward-based_2") && std::find(at_risk_wards.begin(), at_risk_wards.end(), (pop_hosp_loc(i,0))) != at_risk_wards.end()) {
      
      int screen = sample(failure_success,1,false,screen_prob_vec)(0);
      
      if (screen==1 && pop_hosp_status(i,0)==0){ward_screening.row(i) = fill_screened_s;  count_tests = count_tests +1 ;}
      if (screen==1 && pop_hosp_status(i,0)==2){ward_screening.row(i) = fill_screened_s;  count_tests = count_tests +1 ;}
      
    }
    
    if(intervention =="patient-based" or intervention =="patient-based_2") {
      
    int screen = sample(failure_success,1,false,screen_prob_vec)(0);
 
    if (screen==1 && pop_hosp_status(i,0)==0) {screened(i)=1; count_tests = count_tests +1 ;}
    if (screen==1 && pop_hosp_status(i,0)==2) {screened(i)=2; count_tests = count_tests +1 ;}

    }
    
    
  }

  

  //adding state for out
  int state_out = nb_wards+1;
  arma::drowvec wards_out_seq = wards_seq;
  wards_out_seq.resize(state_out);
  wards_out_seq(wards_out_seq.size()-1) = state_out;







  //starts a time=1 because 0 already informed

  for(unsigned int time = 0; time<t;time++) {

    rdm_patient  = sample(patient_id,n_patients,false);


    for(unsigned int j = 0; j<n_patients;j++) {
      
      

     //Rcout<< j;

      int p = rdm_patient(j);

      int current_ward = pop_hosp_loc(p,time);

      // giving submatrix : rows in span  index_TM(0) --> index_TM(1)-1
      storage_adm_TM = WT_matrix(arma::span(index_TM(admission_route(p)-1),index_TM(admission_route(p))-1),arma::span(0,nb_wards));
      storage_adm_TM =  storage_adm_TM.t();
      arma::dcolvec prob_ward =storage_adm_TM.col(current_ward-1);//minus 1 because first index = 0

      // Rcout<< index_PPM(admission_ward(p)-1);
      // Rcout<< index_PPM(admission_ward(p))-1;

      storage_adm_PPM = PPM_matrix(arma::span(index_PPM(admission_route(p)-1),index_PPM(admission_route(p))-1),arma::span(0,(nb_procedures-1)));
      storage_adm_PPM =storage_adm_PPM.t();
      //Rcout<< storage_adm_PPM;
      //Rcout << prob_ward;
      pop_proc(p,time) = sample(proc_seq,1,false, storage_adm_PPM.col(pop_hosp_loc(p,time)-1))(0); // random draw of proc in prob linked to selected ward

      //Rcout<<PPM_matrix.col(pop_hosp_loc(p,time)-1);

      int current_ward_new = pop_hosp_loc(p,time);

      int current_proc = pop_proc(p,time) ;

      int viremic_status = pop_hosp_status(p,time) ; // viremic status for given a patient

// 
//       if(patient_followup == true && p == 10) {
// 
//         patient_fstatus(time) = pop_hosp_status(p,time) ;
//         patient_floc(time) = pop_hosp_loc(p,time) ;
//         patient_fproc(time) = pop_proc(p,time) ;
// 
//       }


      //Rcout << current_ward_new;
      
      if(viremic_status ==0 &&  mat_patient_ward(p,current_ward_new-1) == 0) {
        
        count_patient_ward(current_ward_new-1) = count_patient_ward(current_ward_new-1)+1;
        
      }
      
      //notifies that patient p has been in ward current_ward_new
      mat_patient_ward(p,current_ward_new-1) = 1;

     
      if (current_proc != (nb_procedures+1)) {vec_nb_proc(current_proc-1) =vec_nb_proc(current_proc-1)+1;}
      
      //Rcout << ward_screening(p,(current_ward_new-1));
      
      // if(time>0) {
      //   if(intervention == "ward-based" && 
      //      ward_screening(p,current_ward_new-1) == 0 && 
      //      std::find(at_risk_wards.begin(), at_risk_wards.end(), current_ward_new) != at_risk_wards.end() &&
      //      pop_hosp_loc(p,time-1) != pop_hosp_loc(p,time)) {
      //     
      //     int screen = sample(failure_success,1,false,screen_prob_vec)(0);
      //     
      //     if (screen==1 && pop_hosp_status(p,current_ward_new-1)==0) {ward_screening(p,(current_ward_new-1))=1;  count_tests = count_tests +1 ;}
      //     if (screen==1 && pop_hosp_status(p,current_ward_new-1)==2) {ward_screening(p,(current_ward_new-1))=2;  count_tests = count_tests +1 ;}
      //     
      //   } 
      //   
      // }
      
      if(time>0) {
        if(intervention == "ward-based" && 
           ward_screening(p,current_ward_new-1) == 0 && 
           std::find(at_risk_wards.begin(), at_risk_wards.end(), current_ward_new) != at_risk_wards.end() &&
           pop_hosp_loc(p,time-1) != pop_hosp_loc(p,time)) {
          
          int screen = sample(failure_success,1,false,screen_prob_vec)(0);
          
          if (screen==1 && pop_hosp_status(p,current_ward_new-1)==0) {ward_screening.row(p) = fill_screened_s;  count_tests = count_tests +1 ;}
          if (screen==1 && pop_hosp_status(p,current_ward_new-1)==2) {ward_screening.row(p) = fill_screened_i;  count_tests = count_tests +1 ;}
          
        } 
        
      }
 
      //Rcout << "ici";
      //for infected patients
      //current_proc != nb_proc because nb_procth procedure = no procedure
      if((viremic_status == 2 or viremic_status == 3) && current_proc != nb_procedures && current_ward_new != state_out) {
        

        //list of involved equipments in given procedure
        arma::irowvec list_equip = list_proc_equip(current_proc-1);

        //loop over involved equipments
        for(int eq = 0; eq< list_equip.n_cols; eq++ ) {

          
        
        int current_equipment = list_equip(eq); 
          
        eq_usage(current_equipment-1,current_ward_new-1) = eq_usage(current_equipment-1,current_ward_new-1) + 1;

        float n_available = N_mat(current_equipment-1,current_ward_new-1); //nb of total available material for a given proc and ward

        float n_pu = Npu_mat(current_equipment-1,current_ward_new-1); //nb of total previously used for a given proc and ward


        //random draw for reused material
        int reuse = 0;
        
        // if patient positive upon admission then we use only already used eq on him
        if(intervention == "patient-based" && screened(p) == 2 ) {reuse = 1;}
        
        if(intervention == "ward-based" && ward_screening(p,current_ward_new-1) == 2) {reuse = 1;}
        
        
        if(n_available > 1 && n_available/nb_material_new[current_equipment-1,current_ward_new-1]<threshold_reuse(current_equipment-1)) {
    
          float prob_reuse= 1-(n_available/nb_material_new[current_equipment-1,current_ward_new-1]);
          arma::dcolvec vec_prob_reuse = {1-prob_reuse,prob_reuse};
          
          reuse = sample(failure_success,1,false,vec_prob_reuse)(0);}
        
        //if no more available material
        if(n_available < 1) {reuse = 1;}

        //if no previously used material
        if(n_pu == 0) {reuse = 0;}

        //probability of reused material being contaminated

        //if reusing draw to know if reused mat is contaminated
        if(reuse == 1) {
          
          used_mat(current_equipment-1) = used_mat(current_equipment-1)+1;

          float n_c = C_mat(current_equipment-1,current_ward_new-1);
          double prob_Cpw = n_c / n_pu; // prob of drawing a contaminated equipment

          //if(prob_Cpw > 1) {Rcout<< prob_Cpw; prob_Cpw=1;}

          //Rcout<<prob_Cpw ;
          arma::dcolvec vec_prob_Cpw = {1-prob_Cpw,prob_Cpw};

          int draw_mat = sample(failure_success,1,false,vec_prob_Cpw)(0);

          //if material not previously contaminated, it becomes contaminated with a probability equal to sterilization efficiency for the given equipment
          if(draw_mat==0){

            // probability of equipment being well sterilized
            double prob_ster = sterilization_prob(current_equipment-1);
            arma::dcolvec vec_prob_ster = {1-prob_ster,prob_ster};
            int sterilized = sample(failure_success,1,false,vec_prob_ster)(0);

            //if patient is detected as positive
            if( (intervention == "patient-based_2" && screened(p) == 2) or (intervention == "ward-based_2" && ward_screening(p,current_ward_new-1) == 2)) {sterilized = 1;}

            // if sterilization fails
            if(sterilized==0) {C_mat(current_equipment-1,current_ward_new-1) = C_mat(current_equipment-1,current_ward_new-1)+1;}

            }

          //if material previously contaminated, it can be sterilized
          if(draw_mat==1){
            
            cont_mat(current_equipment-1) = cont_mat(current_equipment-1)+1;

            // probability of equipment being well sterilized
            double prob_ster = sterilization_prob(current_equipment-1);
            arma::dcolvec vec_prob_ster = {1-prob_ster,prob_ster};
            int sterilized = sample(failure_success,1,false,vec_prob_ster)(0);

            //if patient is detected as positive
            //if(screened(p) == 2) {sterilized = 1;}

            // if sterilization is effective
            if(sterilized==1) {C_mat(current_equipment-1,current_ward_new-1) = C_mat(current_equipment-1,current_ward_new-1)-1;}

          }

          }

        //if not reusing material then it gets contaminated depending on the good sterilization prob
        if(reuse == 0) {

          //adding 1 to matrix of previously used material
          Npu_mat(current_equipment-1,current_ward_new-1) = Npu_mat(current_equipment-1,current_ward_new-1) + 1;

          //removing 1 to matrix of available material
          N_mat(current_equipment-1,current_ward_new-1) = N_mat(current_equipment-1,current_ward_new-1)-1;

          double prob_ster = sterilization_prob(current_equipment-1);
          arma::dcolvec vec_prob_ster = {1-prob_ster,prob_ster};
          int sterilized = sample(failure_success,1,false,vec_prob_ster)(0);

          //if patient is detected as positive
          if( (intervention == "patient-based_2" && screened(p) == 2) or (intervention == "ward-based_2" && ward_screening(p,current_ward_new-1) == 2)) {sterilized = 1;}

          //material becomes contaminated
          if(sterilized==0) {C_mat(current_equipment-1,current_ward_new-1) = C_mat(current_equipment-1,current_ward_new-1)+1;}

        }

        }

      }

      //patients that are infected but not infectious
      if (viremic_status == 1 && current_proc != nb_procedures && current_ward_new != state_out) {

        //list of involved equipments in given procedure
        arma::irowvec list_equip = list_proc_equip(current_proc-1);

        //loop over involved equipments
        for(int eq = 0; eq< list_equip.n_cols; eq++ ) {

        int current_equipment = list_equip(eq);
          
          eq_usage(current_equipment-1,current_ward_new-1) = eq_usage(current_equipment-1,current_ward_new-1) + 1;

          float n_available = N_mat(current_equipment-1,current_ward_new-1); //nb of total available material for a given proc and ward

          float n_pu = Npu_mat(current_equipment-1,current_ward_new-1); //nb of total previously used for a given proc and ward


          //random draw for reused material
          int reuse = 0;
          
          // if(time>0) {
          // if(intervention == "ward-based" && 
          //    ward_screening(p,current_ward_new-1) == 0 && 
          //    std::find(at_risk_wards.begin(), at_risk_wards.end(), current_ward_new) != at_risk_wards.end() &&
          //    pop_hosp_loc(p,time-1) != pop_hosp_loc(p,time)) {
          //   
          //   int screen = sample(failure_success,1,false,screen_prob_vec)(0);
          //   
          //   if (screen==1 && pop_hosp_status(p,current_ward_new-1)==0) {ward_screening(p,(pop_hosp_loc(p,current_ward_new-1)-1))=1;  count_tests = count_tests +1 ;}
          //   if (screen==1 && pop_hosp_status(p,current_ward_new-1)==2) {ward_screening(p,(pop_hosp_loc(p,current_ward_new-1)-1))=2;  count_tests = count_tests +1 ;}
          //   
          // }
          // 
          // }

          //if no more available material
          if(n_available < 1) {reuse = 1;}
          
          if(n_available > 1 && n_available/nb_material_new[current_equipment-1,current_ward_new-1]<threshold_reuse(current_equipment-1)) {
            
            float prob_reuse= 1-(n_available/nb_material_new[current_equipment-1,current_ward_new-1]);
            arma::dcolvec vec_prob_reuse = {1-prob_reuse,prob_reuse};
            
            reuse = sample(failure_success,1,false,vec_prob_reuse)(0);}

          //if no previously used material
          if(n_pu == 0) {reuse = 0;}

        //if no reuse
        if(reuse == 0) {

          Npu_mat(current_equipment-1,current_ward_new-1) = Npu_mat(current_equipment-1,current_ward_new-1) + 1;
          N_mat(current_equipment-1,current_ward_new-1) = N_mat(current_equipment-1,current_ward_new-1)-1;

          }

        //if reusing draw to know if reused mat is contaminated
        if(reuse == 1) {
          
                   
          used_mat(current_equipment-1) = used_mat(current_equipment-1)+1;

          float n_c = C_mat(current_equipment-1,current_ward_new-1);
          double prob_Cpw = n_c / n_pu; // prob of drawing a contaminated equipment
          //if(prob_Cpw > 1) {Rcout<< prob_Cpw; prob_Cpw=1;}

          //Rcout<<prob_Cpw ;
          arma::dcolvec vec_prob_Cpw = {1-prob_Cpw,prob_Cpw};

          int draw_mat = sample(failure_success,1,false,vec_prob_Cpw)(0);

          //if material contaminated
          if(draw_mat==1){
            
            cont_mat(current_equipment-1) = cont_mat(current_equipment-1)+1;

            // probability of equipment being well sterilized
            double prob_ster = sterilization_prob(current_equipment-1);
            arma::dcolvec vec_prob_ster = {1-prob_ster,prob_ster};
            int sterilized = sample(failure_success,1,false,vec_prob_ster)(0);

            // if sterilization is well performed
            if(sterilized==1) {C_mat(current_equipment-1,current_ward_new-1) = C_mat(current_equipment-1,current_ward_new-1)-1;}

          }
        }

        }



      }

  
      //susceptible patients
      if (viremic_status == 0 && current_proc != nb_procedures && current_ward_new != state_out) {

        //list of involved equipments in given procedure
        arma::irowvec list_equip = list_proc_equip(current_proc-1);

        // Vector of the prob of equipment being contaminated (used if multiple equipments for one procedure)
        arma::drowvec prob_eq_vec(list_equip.n_cols);

        //loop over involved equipments
        for(int eq = 0; eq< list_equip.n_cols; eq++ ) {

          int current_equipment = list_equip(eq); 
          
          eq_usage(current_equipment-1,current_ward_new-1) = eq_usage(current_equipment-1,current_ward_new-1) + 1;

          float n_available = N_mat(current_equipment-1,current_ward_new-1); //nb of total available material for a given proc and ward

          float n_pu = Npu_mat(current_equipment-1,current_ward_new-1); //nb of total previously used for a given proc and ward

          //random draw for reused material
          int reuse = 0;

          // if(time>0) {
          // if(intervention == "ward-based" && 
          //    ward_screening(p,current_ward_new-1) == 0 && 
          //    std::find(at_risk_wards.begin(), at_risk_wards.end(), current_ward_new) != at_risk_wards.end() &&
          //    pop_hosp_loc(p,time-1) != pop_hosp_loc(p,time)) {
          //   
          //   int screen = sample(failure_success,1,false,screen_prob_vec)(0);
          //   
          //   if (screen==1 && pop_hosp_status(p,current_ward_new-1)==0) {ward_screening(p,(pop_hosp_loc(p,current_ward_new-1)-1))=1;  count_tests = count_tests +1 ;}
          //   if (screen==1 && pop_hosp_status(p,current_ward_new-1)==2) {ward_screening(p,(pop_hosp_loc(p,current_ward_new-1)-1))=2;  count_tests = count_tests +1 ;}
          //   
          // }
          // 
          // }
          // 
          //if no more available material
          if(n_available < 1) {reuse = 1;}
          
          if(n_available > 1 && n_available/nb_material_new[current_equipment-1,current_ward_new-1]<threshold_reuse(current_equipment-1)) {
            
            float prob_reuse= 1-(n_available/nb_material_new[current_equipment-1,current_ward_new-1]);
            arma::dcolvec vec_prob_reuse = {1-prob_reuse,prob_reuse};
            
            reuse = sample(failure_success,1,false,vec_prob_reuse)(0);}

          //if no previously used material
          if(n_pu == 0) {reuse = 0;}


          //probability of reused material being contaminated

          //if reusing draw to know if reused mat is contaminated
          if(reuse == 1) {
            
          

            used_mat(current_equipment-1) = used_mat(current_equipment-1)+1;


            float n_c = C_mat(current_equipment-1,current_ward_new-1);
            double prob_Cpw = n_c / n_pu; // prob of drawing a contaminated equipment

            if(prob_Cpw > 1) {Rcout<< prob_Cpw; prob_Cpw=1;}

            //Rcout<<prob_Cpw ;

            arma::dcolvec vec_prob_Cpw = {1-prob_Cpw,prob_Cpw};

            int draw_mat = sample(failure_success,1,false,vec_prob_Cpw)(0);

            prob_eq_vec(eq) = draw_mat;

            //if material contaminated
            if(draw_mat==1){
              
              cont_mat(current_equipment-1) = cont_mat(current_equipment-1)+1;

              // probability of equipment being well sterilized
              double prob_ster = sterilization_prob(current_equipment-1);
              arma::dcolvec vec_prob_ster = {1-prob_ster,prob_ster};
              int sterilized = sample(failure_success,1,false,vec_prob_ster)(0);

              // if sterilization is as success
              if(sterilized==1) {C_mat(current_equipment-1,current_ward_new-1) = C_mat(current_equipment-1,current_ward_new-1)-1;}

            }

          }

          //no reuse
          if(reuse == 0) {

            Npu_mat(current_equipment-1,current_ward_new-1) = Npu_mat(current_equipment-1,current_ward_new-1) + 1;
            N_mat(current_equipment-1,current_ward_new-1) = N_mat(current_equipment-1,current_ward_new-1)-1;
          }

        }


          //Rcpp:Rcout << time;

          //Rcout<< prob_eq_vec;

          //if a least 1 eq is contaminated
          if(sum(prob_eq_vec) >= 1) {


          StringVector vec_dist = dist_risk["dist"];

          if(vec_dist(current_proc-1)=="lnorm") {


            arma::fvec lmean_vec = dist_risk[0];

            arma::fvec lsd_vec = dist_risk[1];

            float lmean_risk = lmean_vec(current_proc-1); //parameter 1 for lognormal dist

            float lsd_risk = lsd_vec(current_proc-1); //parameter 2 for lognormal dist

            float risk_p = Rcpp::as<float> (random_lnorm(_["n"]=1,_["meanlog"]=lmean_risk,_["sdlog"]=lsd_risk)); //risk of getting HCV contaminated if material is contaminated

            //Probability of going from the S to the E state
            float prob_E = risk_p;

            if (prob_E<0) {prob_E=0;}
            if (prob_E>1) {prob_E=1;}

       
            arma::dcolvec prob_inf_vector = {1-prob_E,prob_E};

            int draw_infection = sample(cont_neg_vec,1,false,prob_inf_vector)(0);

            if (draw_infection == 1) {pop_hosp_status(p,time) = 1; incidence(time)=incidence(time)+1; ward_event(current_ward_new-1)= ward_event(current_ward_new-1)+1; 

for(int ei = 0; ei < list_equip.n_cols; ei++) {if(prob_eq_vec(ei)==1) {inf_eq(list_equip(ei)-1) = inf_eq(list_equip(ei)-1)+1;} } 

}

          }

          if(vec_dist(current_proc-1)=="norm") {

            arma::fvec mean_vec = dist_risk[0];

            arma::fvec sd_vec = dist_risk[1];

            float mean_risk = mean_vec(current_proc-1); //parameter 1 for normal dist

            float sd_risk = sd_vec(current_proc-1); //parameter 2 for normal dist

            float risk_p = Rcpp::as<float> (random_norm(_["n"]=1,_["mean"]=mean_risk,_["sd"]=sd_risk)); //risk of getting HCV contaminated if material is contaminated

            //Probability of going from the S to the E state
            float prob_E = risk_p;

            if (prob_E<0) {prob_E=0;}
            if (prob_E>1) {prob_E=1;}

          

            arma::dcolvec prob_inf_vector = {1-prob_E,prob_E};

            int draw_infection = sample(cont_neg_vec,1,false,prob_inf_vector)(0);

            if (draw_infection == 1) {pop_hosp_status(p,time) = 1; incidence(time)=incidence(time)+1; ward_event(current_ward_new-1)= ward_event(current_ward_new-1)+1;

for(int ei = 0; ei < list_equip.n_cols; ei++) {if(prob_eq_vec(ei)==1) {inf_eq(list_equip(ei)) = inf_eq(list_equip(ei)-1)+1;} } 
}

          }

          if(vec_dist(current_proc-1)=="pert") {

            arma::fvec min_vec = dist_risk[0];

            arma::fvec mode_vec = dist_risk[1];

            arma::fvec max_vec = dist_risk[2];

            float min_risk = min_vec(current_proc-1); //parameter 1 for pert dist

            float mode_risk = mode_vec(current_proc-1); //parameter 2 for pert dist

            float max_risk = max_vec(current_proc-1); //parameter 3 for pert dist

            float risk_p = Rcpp::as<float> (random_pert(_["n"]=1,_["min"]=min_risk,_["mode"]=mode_risk,_["max"]=max_risk))/100; //risk of getting HCV contaminated if material is contaminated

            //Probability of going from the S to the E state
            float prob_E = risk_p;

            if (prob_E<0) {prob_E=0;}
            if (prob_E>1) {prob_E=1;}

           

            arma::dcolvec prob_inf_vector = {1-prob_E,prob_E};

            int draw_infection = sample(cont_neg_vec,1,false,prob_inf_vector)(0);

            if (draw_infection == 1) {pop_hosp_status(p,time) = 1; incidence(time)=incidence(time)+1; ward_event(current_ward_new-1)= ward_event(current_ward_new-1)+1;

for(int ei = 0; ei < list_equip.n_cols; ei++) {if(prob_eq_vec(ei)==1) {inf_eq(list_equip(ei)-1) = inf_eq(list_equip(ei)-1)+1;} } 
}

          }


        }

      }

      
     
      

      // available_mat_time.col(time+1) = sum(N_mat,1);

      // used_mat_time.col(time+1) = sum(Npu_mat,1);
      // contaminated_mat_time.col(time+1) = sum(C_mat,1);


      //adding 1 to status counter
      if(pop_hosp_status(p,time) == 1) {state_counter(p) = state_counter(p) + 1;}

      //if counter exceed the time of the eclipse phase then patient goes from E to I
      if(state_counter(p) >= e_phase(p) && pop_hosp_status(p,time) == 1 ) {pop_hosp_status(p,time) = 3; }


      pop_hosp_loc(p,time+1) = sample(wards_out_seq,1,false,prob_ward)(0); //first ward for new patient
      
      
      pop_hosp_status(p,time+1) = pop_hosp_status(p,time); //patient has same status than time before

      //pop_proc(p,time+1) = pop_proc(p,time);


      if(pop_hosp_status(p,time)==0) {s_patients(time)=s_patients(time)+1; ward_s(current_ward-1,time)=ward_s(current_ward-1,time)+1;}

     
      test_eq(time) = N_mat(4,1);
      
      test_eq_u(time) = Npu_mat(4,1) - C_mat(4,1); 
        
      test_eq_cont(time) =C_mat(4,1);
        
      // if a patient leaves the hospital, another one is entering
      if( pop_hosp_loc(p,time+1) == state_out) {

       //initialize to zero so that history of passing through wards is clear for new patient
       mat_patient_ward.row(p) = init_patient_wards;
        
       ward_screening.row(p) = init_patient_wards;
        
       count_patients = count_patients +1;

       
        new_patient_vec(time) = new_patient_vec(time)+1;

        arma::ucolvec new_departure = {time+1,p};
        patient_departure = join_horiz(patient_departure ,new_departure) ;
          
        admission_route(p) = sample(adm_seq,1,false,adm_prob)(0);
        storage_init_prob= init_prob.row(admission_route(p)-1);
        pop_hosp_loc(p,time+1) = sample(wards_seq,1,false,storage_init_prob.t())(0);//if patient leaves the hospital, another patient instantly replaces him

        //count_patient_ward(pop_hosp_loc(p,time+1)-1) =   count_patient_ward(pop_hosp_loc(p,time+1)-1)+1;      
 
        state_counter(p) = 0; //if patient leaves the hospital, counter of infection for patient p goes back to 0
       
       if(prev_type == "ward") {
           
         arma::dcolvec pos_neg_prob = {1-prev_init((pop_hosp_loc(p,time+1)-1)),prev_init((pop_hosp_loc(p,time+1)-1))};
         
         //test if patient is infected depending on adm route
         pop_hosp_status(p,time+1) = sample(pos_neg_vec,1,false,pos_neg_prob)(0);
         
       }
        
        if(prev_type == "hospital") {
          
        arma::dcolvec pos_neg_prob = {1-prev_init((admission_route(p)-1)),prev_init((admission_route(p)-1))};

        //test if patient is infected depending on adm route
        pop_hosp_status(p,time+1) = sample(pos_neg_vec,1,false,pos_neg_prob)(0);
        
        }

       e_phase(p) = round(Rcpp::runif(1,min_e_phase,max_e_phase)(0));

        
        screened(p)=0;
        
        // if(intervention == "ward-based" && std::find(at_risk_wards.begin(), at_risk_wards.end(), (pop_hosp_loc(p,time+1))) != at_risk_wards.end()) {
        //   
        //   int screen = sample(failure_success,1,false,screen_prob_vec)(0);
        //   
        //   if (screen==1 && pop_hosp_status(p,pop_hosp_loc(p,time+1)-1)==0) {ward_screening(p,(pop_hosp_loc(p,time+1)-1))=1;  count_tests = count_tests +1 ;}
        //   if (screen==1 && pop_hosp_status(p,pop_hosp_loc(p,time+1)-1)==2) {ward_screening(p,(pop_hosp_loc(p,time+1)-1))=2;  count_tests = count_tests +1 ;}
        //   
        // }
        
        if(intervention =="patient-based") {
        
        int screen_new = sample(failure_success,1,false,screen_prob_vec)(0);

        if (screen_new==1 && pop_hosp_status(p,time+1)==0) {screened(p)=1;  count_tests = count_tests +1 ;}

        if (screen_new==1 && pop_hosp_status(p,time+1)==2) {screened(p)=2;  count_tests = count_tests +1 ;}

        }
        
      }

      
      //count_patient_ward(pop_hosp_loc(p,time+1)-1) =   count_patient_ward(pop_hosp_loc(p,time+1)-1)+1;

      
      // if ( std::find(vec.begin(), vec.end(), item) != vec.end() )

        // if(pop_hosp_status(p,time)==0 &&  mat_patient_ward(p,current_ward_new-1) == 0) {
        // 
        //   count_patient_ward(current_ward_new-1) = count_patient_ward(current_ward_new-1)+1;
        // 
        // }

        // if((pop_hosp_status(p,time)==1 or pop_hosp_status(p,time)==2 or pop_hosp_status(p,time)==3)
        //      &&  mat_patient_ward(p,current_ward_new-1) == 0) {
        // 
        //   count_patient_ward(current_ward_new-1) = count_patient_ward(current_ward_new-1)+1;
        // 
        // }
  
      
    }

  

  
    

    // check if there s a need to refill equipment or throw away equipment
    for(unsigned int rf=0;rf<nb_equipments;rf++) {

      for(unsigned int w = 0; w<nb_wards; w++) {

        if(eq_quantity=="variable") {
        if(refill_counter(rf,w)>= refill_freq(rf,w)) {N_mat(rf,w)=refill_quantities(rf,w); refill_counter(rf,w) = 0;}
        else {refill_counter(rf,w)=refill_counter(rf,w)+1;}

        if(bin_counter(rf,w)>= equip_bin(rf,w)) {C_mat(rf,w)=0; Npu_mat(rf,w)=0; bin_counter(rf,w) = 0;}
        else {bin_counter(rf,w)=bin_counter(rf,w)+1;}

        }

        if(refill_counter(rf,w)>= refill_freq(rf,w)){

        refill_counter(rf,w) = 0;

        if(eq_quantity=="fixed") {

          //N_mat(rf,w) =  N_mat(rf,w) + Npu_mat(rf,w);
          N_mat(rf,w) =  N_mat(rf,w)+refill_quantities(rf,w);
          C_mat(rf,w)=0;
          Npu_mat(rf,w)=0;

        }

        }

        else {refill_counter(rf,w)=refill_counter(rf,w)+1;}

      }

    }

    if(output== "all") { 
    available_mat_time.slice(time+1) = N_mat;
    cont_mat_time.slice(time+1) = C_mat;
    used_mat_time.slice(time+1) = Npu_mat;
    }

  }

  //removing last column because because size = time+1
  pop_hosp_status.shed_col(t);
  
  if(output== "all") { 
  available_mat_time.shed_slice(0);
  used_mat_time.shed_slice(0);
  cont_mat_time.shed_slice(0);
  }

  if(output=="all") {
  List L = List::create(_["patient_location"] = pop_hosp_loc,
                        _["patient_status"] = pop_hosp_status,
                        _["patient_procedure"] = pop_proc,
                        _["patient_departure"] = patient_departure,
                        _["followup_status"] = patient_fstatus,
                        _["followup_location"] = patient_floc,
                        _["followup_procedure"] = patient_fproc,
                        _["new_material"] = available_mat_time,
                        _["contaminated_material"] = cont_mat_time,
                        _["used_material"] = used_mat_time,
                        _["incidence"]=incidence);

  return L;}

  if(output=="simple") {
    List L = List::create(_["incidence"] = incidence,
                          _["new_patients"] = new_patient_vec,
                          _["s_patients"] = s_patients,
                          _["cont_new_patients"] = cont_new_patient_vec,
                          _["ward_event"] = ward_event,
                          _["ward_s"] = ward_s,
                          _["count_patients"] = count_patients,
                          _["cont_mat"] = cont_mat,
                          _["used_mat"] = used_mat,
                          _["list_proc_equip"] = list_proc_equip,
                          _["vec_nb_proc"] = vec_nb_proc,
                          _["inf_eq"] = inf_eq,
                          _["count_patient_ward"] = count_patient_ward,
                          _["cont_new_patient_ward"] = cont_new_patient_ward,
                          _["count_tests"]= count_tests,
                          _["test_eq"]= test_eq,
                          _["test_eq_u"]= test_eq_u,
                          _["test_eq_cont"]= test_eq_cont,
                          _["eq_usage"]= eq_usage);

    return L;}


}
